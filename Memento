# ПАТТЕРН СНИМОК(Memento)
***
## Авторы:

Ижбулдин Илья Евгеньевич 
Иксанов Алмаз Рифович
***
***Снимок*** — это поведенческий паттерн проектирования, который позволяет сохранять и восстанавливать прошлые состояния объектов, не раскрывая подробностей их реализации.  
***Снимок*** - шаблон, который позволяет сохранять состояние (т.е. данные) объекта и восстанавливать это состояние при необходимости.
![](https://radioprog.ru/uploads/media/articles/0001/06/5d436e98347d6969d6d882fe48bc59d410cb0707.png)
***
# Проблема
Предположим, что вы пишете программу текстового редактора. Помимо обычного редактирования, ваш редактор позволяет менять форматирование текста, вставлять картинки и прочее.

В какой-то момент вы решили сделать все эти действия отменяемыми. Для этого вам нужно сохранять текущее состояние редактора перед тем, как выполнить любое действие. Если потом пользователь решит отменить своё действие, вы достанете копию состояния из истории и восстановите старое состояние редактора.
![](https://radioprog.ru/uploads/media/articles/0001/06/eafd991d9e61059019d9b63175dc4ae4c0123e76.png)  
Чтобы сделать копию состояния объекта, достаточно скопировать значение его полей. Таким образом, если вы сделали класс редактора достаточно открытым, то любой другой класс сможет заглянуть внутрь, чтобы скопировать его состояние.

Казалось бы, что ещё нужно? Ведь теперь любая операция сможет сделать резервную копию редактора перед своим действием. Но такой наивный подход обеспечит вам уйму проблем в будущем. Ведь если вы решите провести рефакторинг – убрать или добавить парочку полей в класс редактора – то придётся менять код всех классов, которые могли копировать состояние редактора.  

![](https://radioprog.ru/uploads/media/articles/0001/06/4b425673dfcac0e02bb2d5c2778ad65e293abea6.png)    
Но это ещё не все. Давайте теперь рассмотрим сами копии состояния редактора. Из чего состоит состояние редактора? Даже самый примитивный редактор должен иметь несколько полей для хранения текущего текста, позиции курсора и прокрутки экрана. Чтобы сделать копию состояния, вам нужно записать значения всех этих полей в некий «контейнер».

Скорее всего, вам понадобится хранить массу таких контейнеров в качестве истории операций, поэтому удобнее всего сделать их объектами одного класса. Этот класс должен иметь много полей, но практически никаких методов. Чтобы другие объекты могли записывать и читать из него данные, вам придётся сделать его поля публичными. Но это приведёт к той же проблеме, что и с открытым классом редактора. Другие классы станут зависимыми от любых изменений в классе контейнера, который подвержен тем же изменениям, что и класс редактора.

Получается, нам придётся либо открыть классы для всех желающих, испытывая массу хлопот с поддержкой кода, либо оставить классы закрытыми, отказавшись от идеи отмены операций. Нет ли какого-то другого пути?
 
***
  # Решение
 Все проблемы, описанные выше, возникают из-за нарушения инкапсуляции. Это когда одни объекты пытаются сделать работу за других, влезая в их приватную зону, чтобы собрать необходимые для операции данные.

Паттерн Снимок поручает создание копии состояния объекта самому объекту, который этим состоянием владеет. Вместо того, чтобы делать снимок «извне», наш редактор сам сделает копию своих полей, ведь ему доступны все поля, даже приватные.

Паттерн предлагает держать копию состояния в специальном объекте-снимке с ограниченным интерфейсом, позволяющим, например, узнать дату изготовления или название снимка. Но, с другой стороны, снимок должен быть открыт для своего создателя, позволяя прочесть и восстановить его внутреннее состояние.  
![](https://radioprog.ru/uploads/media/articles/0001/06/08a66c7f126bfb9a4ce1af59703a91a31a896153.png)   
Такая схема позволяет создателям производить снимки и отдавать их для хранения другим объектам, называемым опекунами. Опекунам будет доступен только ограниченный интерфейс снимка, поэтому они никак не смогут повлиять на «внутренности» самого снимка. В нужный момент опекун может попросить создателя восстановить своё состояние, передав ему соответствующий снимок.

В примере с редактором вы можете сделать опекуном отдельный класс, который будет хранить список выполненных операций. Ограниченный интерфейс снимков позволит демонстрировать пользователю красивый список с названиями и датами выполненных операций. А когда пользователь решит откатить операцию, класс истории возьмёт последний снимок из стека и отправит его объекту редактор для восстановления.

  ***
  # Пример: 
  ```
  class Memento(object):
    def __init__(self, state):
        self._state = state
 
    def get_state(self):
        return self._state
 
 
class Caretaker(object):
    def __init__(self):
        self._memento = None
 
    def get_memento(self):
        return self._memento
 
    def set_memento(self, memento):
        self._memento = memento
 
 
class Originator(object):
    def __init__(self):
        self._state = None
 
    def set_state(self, state):
        self._state = state
 
    def get_state(self):
        return self._state
 
    def save_state(self):
        return Memento(self._state)
 
    def restore_state(self, memento):
        self._state = memento.get_state()
 
 
originator = Originator()
caretaker = Caretaker()
 
originator.set_state('on')
print 'Originator state:', originator.get_state()  # Originator state: on
caretaker.set_memento(originator.save_state())
 
originator.set_state('off')
print 'Originator change state:', originator.get_state()  # Originator change state: off
 
originator.restore_state(caretaker.get_memento())
print 'Originator restore state:', originator.get_state()  # Originator restore state: on
```
 # Преимущества и недостатки

### Преимущества

* Не нарушает инкапсуляции исходного объекта.
* Упрощает структуру исходного объекта. Ему не нужно хранить историю версий своего состояния.

### Недостатки

* Требует много памяти, если клиенты слишком часто создают снимки.
* Может повлечь дополнительные издержки памяти, если объекты, хранящие историю, не освобождают ресурсы, занятые устаревшими снимками.
* В некоторых языках (например, PHP, Python, JavaScript) сложно гарантировать, чтобы только исходный объект имел доступ к состоянию снимка.
